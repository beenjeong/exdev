<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE mapper PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN" 
"http://mybatis.org/dtd/mybatis-3-mapper.dtd">

<mapper namespace="admin">

	<cache />

	<!--
	SP CUSTOM 관리 
	 -->	
	<select id="getSpCustomerList" resultType="java.util.HashMap" flushCache="true"  useCache="false">
		/*	admin.getSpCustomerList
			SP CUSTOMER 리스트 조회 
		*/
		SELECT SP_CSTM_ID 
		,SP_CSTM_NM
		,SP_CSTM_DESC
		,USE_YN
		,DEL_YN
		,UPDATE_USER
		,TO_CHAR( UPDATE_DATE , 'YYYY-MM-DD HH24:MI:SS' ) UPDATE_DATE 
		FROM ADMIN.TBL_EXP_SP_CSTM T
		WHERE 1 = 1
	</select>
	
	<update id="updateSpCustomer" parameterType="java.util.HashMap"  flushCache="true" >
		/*	admin.updateSpCustomer
			SP CUSTOMER  저장
		*/
		MERGE INTO ADMIN.TBL_EXP_SP_CSTM T
		USING (
		  SELECT #{SP_CSTM_NM} AS SP_CSTM_NM,
		         #{SP_CSTM_DESC} AS SP_CSTM_DESC,
		         #{USE_YN} AS USE_YN,
		         #{DEL_YN} AS DEL_YN,
		         'admin' AS UPDATE_USER,
		         SYSDATE AS UPDATE_DATE
		  FROM dual
		) S
		ON (T.SP_CSTM_ID = S.SP_CSTM_ID)
		WHEN MATCHED THEN
		  UPDATE SET
		    T.SP_CSTM_NM = S.SP_CSTM_NM,
		    T.SP_CSTM_DESC = S.SP_CSTM_DESC,
		    T.USE_YN = S.USE_YN,
		    T.DEL_YN = S.DEL_YN,
		    T.UPDATE_USER = S.UPDATE_USER,
		    T.UPDATE_DATE = S.UPDATE_DATE
		WHEN NOT MATCHED THEN 
    		INSERT (SP_CSTM_ID,SP_CSTM_NM,SP_CSTM_DESC,USE_YN,DEL_YN,UPDATE_USER,UPDATE_DATE)
		  	VALUES (S.SP_CSTM_ID,S.SP_CSTM_NM,S.SP_CSTM_DESC,S.USE_YN,S.DEL_YN,S.UPDATE_USER,S.UPDATE_DATE)
	</update>
	
	<delete id="deleteSpCustomer" parameterType="java.util.HashMap"  flushCache="true" >
		/*	admin.deleteSpCustomer
			SP CUSTOMER 삭제
		*/
		DELETE FROM ADMIN.TBL_EXP_SP_CSTM 
		WHERE SP_CSTM_ID = #{SP_CSTM_ID} 
	</delete>
	
	<!--
	MENU 관리 
	 -->	
	<select id="getMenuList" resultType="java.util.HashMap" flushCache="true"  useCache="false">
		/*	admin.getMenuList
			메뉴 리스트 조회 
		*/
		SELECT MENU_ID 
		,MENU_NM,PARENT_MENU_ID,MENU_DEPTH
		,MENU_DESC,PAGE_ID
		,USE_YN
		,UPDATE_USER
		,TO_CHAR( UPDATE_DATE , 'YYYY-MM-DD HH24:MI:SS' ) UPDATE_DATE 
		,SORT_ORDER
		FROM ADMIN.TBL_EXP_MENU T
		WHERE 1 = 1
		<if test=" MENU_NM != null and MENU_NM != '' ">
		AND T.MENU_NM like '%' || #{MENU_NM} || '%'
		</if>
		<if test=" PARENT_MENU_ID != null and PARENT_MENU_ID != '' ">
		AND T.PARENT_MENU_ID like  '%' || #{PARENT_MENU_ID} || '%'
		</if>
		<if test=" MENU_DEPTH != null and MENU_DEPTH != '' ">
		AND T.MENU_DEPTH = #{MENU_DEPTH}
		</if>
		<if test=" MENU_DESC != null and MENU_DESC != '' ">
		AND T.MENU_DESC like '%' || #{MENU_DESC} || '%'
		</if>
		<if test=" PAGE_ID != null and PAGE_ID != '' ">
		AND T.PAGE_ID like '%' || #{PAGE_ID} || '%'
		</if>
		<if test="USE_YN != null and USE_YN != '' ">
		AND T.USE_YN = #{USE_YN}
		</if>
		<if test=" SORT_ORDER != null and SORT_ORDER != '' ">
		AND T.SORT_ORDER = #{SORT_ORDER}
		</if>
		ORDER BY SORT_ORDER
	</select>
	
	<update id="updateMenu" parameterType="java.util.HashMap"  flushCache="true" >
		/*	admin.updateMenu
			메뉴 저장
		*/
		MERGE INTO ADMIN.TBL_EXP_MENU T
		USING (
		  SELECT #{MENU_ID} AS MENU_ID,
		         #{MENU_NM} AS MENU_NM,
		         #{PARENT_MENU_ID} AS PARENT_MENU_ID,
		         #{MENU_DEPTH} AS MENU_DEPTH,
		         #{MENU_DESC} AS MENU_DESC,
		         #{PAGE_ID} AS PAGE_ID,
		        <if test="USE_YN != null">
		         NVL(#{USE_YN},'Y') AS USE_YN,
		        </if>
		        <if test="USE_YN == null">
		         'Y' AS USE_YN,
		        </if>
		        <if test="SORT_ORDER != null">
		         TO_NUMBER(#{SORT_ORDER}) AS SORT_ORDER,
		        </if>
		        <if test="SORT_ORDER == null">
		         100 AS SORT_ORDER,
		        </if>
		         'admin' AS UPDATE_USER,
		         SYSDATE AS UPDATE_DATE
		  FROM dual
		) S
		ON (T.MENU_ID = S.MENU_ID)
		WHEN MATCHED THEN
		  UPDATE SET
		    T.MENU_NM = S.MENU_NM,
		    T.PARENT_MENU_ID = S.PARENT_MENU_ID,
		    T.MENU_DEPTH = S.MENU_DEPTH,
		    T.MENU_DESC = S.MENU_DESC,
		    T.PAGE_ID = S.PAGE_ID,
		    T.USE_YN = S.USE_YN,
		    T.SORT_ORDER = S.SORT_ORDER,
		    T.UPDATE_USER = S.UPDATE_USER,
		    T.UPDATE_DATE = S.UPDATE_DATE
		WHEN NOT MATCHED THEN 
		  INSERT (  MENU_ID,   MENU_NM,   PARENT_MENU_ID,   MENU_DEPTH,   MENU_DESC,   PAGE_ID,   USE_YN,   SORT_ORDER,   UPDATE_USER,   UPDATE_DATE)
		  VALUES (S.MENU_ID, S.MENU_NM, S.PARENT_MENU_ID, S.MENU_DEPTH, S.MENU_DESC, S.PAGE_ID, S.USE_YN, S.SORT_ORDER, S.UPDATE_USER, S.UPDATE_DATE)
	</update>
	
	<delete id="deleteMenu" parameterType="java.util.HashMap"  flushCache="true" >
		/*	admin.deleteMenu
			메뉴 삭제
		*/
		DELETE FROM ADMIN.TBL_EXP_MENU 
		WHERE MENU_ID = #{MENU_ID} 
	</delete>

	<!--
	CODE 관리 
	 -->	
	<select id="getGrpCodeList" resultType="java.util.HashMap" flushCache="true"  useCache="false">
		/*	admin.getGrpCodeList
			그룹 코드 리스트 조회 
		*/
		SELECT 
		 GRP_CODE_ID
		,GRP_CODE_NM
		,CODE_DESC
		,USE_YN
		,DEL_YN
		,SORT_ORDER
		,UPDATE_USER
		,TO_CHAR( UPDATE_DATE , 'YYYY-MM-DD HH24:MI:SS' ) UPDATE_DATE
		,( SELECT COUNT(*) FROM ADMIN.TBL_EXP_CODE I WHERE I.GRP_CODE_ID = T.GRP_CODE_ID ) TBL_EXP_CODE_CNT
		,( SELECT MAX(SORT_ORDER) +10 FROM ADMIN.TBL_EXP_GRPCODE I )  AS NEXT_SORT_ORDER
		FROM ADMIN.TBL_EXP_GRPCODE T
		WHERE 1 = 1
		<if test=" GRP_CODE_ID != null and GRP_CODE_ID != '' ">
		AND T.GRP_CODE_ID like '%' || #{GRP_CODE_ID} || '%'
		</if>
		<if test=" CODE_NM != null and CODE_NM != '' ">
		AND T.GRP_CODE_NM like '%' || #{CODE_NM} || '%'
		</if>
		<if test=" CODE_DESC != null and CODE_DESC != '' ">
		AND T.CODE_DESC like '%' || #{CODE_DESC} || '%'
		</if>
		<if test=" S_USE_YN != null and S_USE_YN != '' ">
		AND T.USE_YN = #{S_USE_YN}
		</if>
		<if test=" S_DEL_YN != null and S_DEL_YN != '' ">
		AND T.DEL_YN = #{S_DEL_YN}
		</if>
		
		
		ORDER BY SORT_ORDER
	</select>
	
	<select id="getCodeList" resultType="java.util.HashMap" flushCache="true"  useCache="false">
		/*	admin.getCodeList
			코드 리스트 조회 
		*/
		SELECT 
		T.GRP_CODE_ID
		,( SELECT GRP_CODE_NM 
			FROM ADMIN.TBL_EXP_GRPCODE I 
			WHERE I.GRP_CODE_ID = T.GRP_CODE_ID) AS GRP_CODE_NM
		,T.CODE_ID
		,T.CODE_NM
		,T.CODE_DESC
		,T.USE_YN
		,T.DEL_YN
		,T.SORT_ORDER
		,T.UPDATE_USER
		,TO_CHAR( T.UPDATE_DATE , 'YYYY-MM-DD HH24:MI:SS' ) UPDATE_DATE
		,( SELECT MAX(SORT_ORDER) +10 FROM ADMIN.TBL_EXP_CODE I 
			WHERE 1=1
			<if test=" GRP_CODE_ID != null and GRP_CODE_ID != '' ">
			AND I.GRP_CODE_ID = #{GRP_CODE_ID} 
			</if>
		 )  AS NEXT_SORT_ORDER
		 ,P.SORT_ORDER
		FROM ADMIN.TBL_EXP_CODE T,
		ADMIN.TBL_EXP_GRPCODE P 
		WHERE T.GRP_CODE_ID = P.GRP_CODE_ID
		<if test=" GRP_CODE_ID != null and GRP_CODE_ID != '' ">
		AND T.GRP_CODE_ID = #{GRP_CODE_ID}
		</if>
		<if test=" CODE_ID != null and CODE_ID != '' ">
		AND T.CODE_ID = #{CODE_ID} 
		</if>
		<if test=" CODE_NM != null and CODE_NM != '' ">
		AND T.CODE_NM like '%' || #{CODE_NM} || '%'
		</if>
		<if test=" CODE_DESC != null and CODE_DESC != '' ">
		AND T.CODE_DESC like '%' || #{CODE_DESC} || '%'
		</if>
		<if test=" S_USE_YN != null and S_USE_YN != '' ">
		AND T.USE_YN = #{S_USE_YN}
		</if>
		<if test=" S_DEL_YN != null and S_DEL_YN != '' ">
		AND T.DEL_YN = #{S_DEL_YN}
		</if>
		ORDER BY P.SORT_ORDER , T.SORT_ORDER	
	</select>

	<update id="updateGrpCode" parameterType="java.util.HashMap"  flushCache="true" >
		/*	admin.updateGrpCode
			그룹 코드 저장
		*/
		MERGE INTO ADMIN.TBL_EXP_GRPCODE T
		USING (
		  SELECT #{GRP_CODE_ID} AS GRP_CODE_ID,
				 #{GRP_CODE_NM} AS GRP_CODE_NM,
				 #{CODE_DESC} 	AS CODE_DESC,
				 #{USE_YN} 		AS USE_YN,
				 #{DEL_YN} 		AS DEL_YN,
				 #{SORT_ORDER} 	AS SORT_ORDER,
				 'admin'		AS UPDATE_USER,
				 SYSDATE 		AS UPDATE_DATE 
		  FROM dual
		) S
		ON (T.GRP_CODE_ID = S.GRP_CODE_ID)
		WHEN MATCHED THEN
		  UPDATE SET
			T.GRP_CODE_NM  =S.GRP_CODE_NM,  
			T.CODE_DESC    =S.CODE_DESC,    
			T.USE_YN       =S.USE_YN,       
			T.DEL_YN       =S.DEL_YN,       
			T.SORT_ORDER   =S.SORT_ORDER,   
			T.UPDATE_USER  =S.UPDATE_USER,  
			T.UPDATE_DATE  =S.UPDATE_DATE   
 		WHEN NOT MATCHED THEN 
		  INSERT (  GRP_CODE_ID,   GRP_CODE_NM,   CODE_DESC,   USE_YN,   DEL_YN,   SORT_ORDER,   UPDATE_USER,   UPDATE_DATE) 
		  VALUES (S.GRP_CODE_ID, S.GRP_CODE_NM, S.CODE_DESC, S.USE_YN, S.DEL_YN, S.SORT_ORDER, S.UPDATE_USER, S.UPDATE_DATE)
	</update>

	<update id="updateCode" parameterType="java.util.HashMap"  flushCache="true" >
		/*	admin.updateCode
			코드 저장
		*/
		MERGE INTO ADMIN.TBL_EXP_CODE T
		USING (
		  SELECT #{GRP_CODE_ID}	AS GRP_CODE_ID, 
				 #{CODE_ID} 	AS CODE_ID, 
				 #{CODE_NM} 	AS CODE_NM, 
				 #{CODE_DESC}	AS CODE_DESC,   
				 #{USE_YN}		AS USE_YN,      
				 #{DEL_YN}		AS DEL_YN,      
				 #{SORT_ORDER} 	AS SORT_ORDER,  
				 'admin'		AS UPDATE_USER, 
				 SYSDATE		AS UPDATE_DATE  
		  FROM dual
		) S
		ON (T.GRP_CODE_ID = S.GRP_CODE_ID
		AND T.CODE_ID	  = S.CODE_ID)
		WHEN MATCHED THEN
		  UPDATE SET
		  		T.CODE_NM		= S.CODE_NM,
				T.CODE_DESC		= S.CODE_DESC, 
				T.USE_YN		= S.USE_YN,    
				T.DEL_YN		= S.DEL_YN,    
				T.SORT_ORDER 	= S.SORT_ORDER,
				T.UPDATE_USER	= S.UPDATE_USER,
				T.UPDATE_DATE	= S.UPDATE_DATE

		WHEN NOT MATCHED THEN 
		  INSERT (  GRP_CODE_ID,  CODE_ID,  CODE_NM,  CODE_DESC,  USE_YN,  DEL_YN,  SORT_ORDER,  UPDATE_USER,  UPDATE_DATE) 
		  VALUES (S.GRP_CODE_ID,S.CODE_ID,S.CODE_NM,S.CODE_DESC,S.USE_YN,S.DEL_YN,S.SORT_ORDER,S.UPDATE_USER,S.UPDATE_DATE) 
 	</update>
 	
	<delete id="deleteGrpCode" parameterType="java.util.HashMap"  flushCache="true" >
		/*	admin.deleteGrpCode
			그룹 코드 삭제
		*/
		DELETE FROM ADMIN.TBL_EXP_GRPCODE 
		WHERE GRP_CODE_ID = #{GRP_CODE_ID} 
	</delete>

	<delete id="deleteCode" parameterType="java.util.HashMap"  flushCache="true" >
		/*	admin.deleteCode
			코드 삭제
		*/
		DELETE FROM ADMIN.TBL_EXP_CODE 
		WHERE GRP_CODE_ID 	= #{GRP_CODE_ID} 
		AND 	CODE_ID 	= #{CODE_ID} 
	</delete>

	<!--
	ROLE 관리 
	 -->	
	<select id="getRoleList" resultType="java.util.HashMap" flushCache="true"  useCache="false">
		/*	admin.getRoleList
			Role 리스트 조회 
		*/
		SELECT SP_CSTM_ID 
		,ROLE_ID
		,ROLE_NM
		,ROLE_DESC
		,USE_YN
		,DEL_YN
		,SORT_ORDER
		,UPDATE_USER
		,TO_CHAR( UPDATE_DATE , 'YYYY-MM-DD HH24:MI:SS' ) UPDATE_DATE 
		FROM ADMIN.TBL_EXP_ROLE T
		WHERE 1 = 1
		ORDER BY SORT_ORDER
	</select>
	
	<update id="updateRole" parameterType="java.util.HashMap"  flushCache="true" >
		/*	admin.updateRole
			Role  저장
		*/
		MERGE INTO ADMIN.TBL_EXP_ROLE T
		USING (
		  SELECT #{SP_CSTM_ID} AS SP_CSTM_ID,
		         #{ROLE_ID} AS ROLE_ID,
		         #{ROLE_NM} AS ROLE_NM,
		         #{ROLE_DESC} AS ROLE_DESC,
		         #{USE_YN} AS USE_YN,
		         #{DEL_YN} AS DEL_YN,
		         #{SORT_ORDER} AS SORT_ORDER,
		         'admin' AS UPDATE_USER,
		         SYSDATE AS UPDATE_DATE
		  FROM dual
		) S
		ON (T.SP_CSTM_ID	= S.SP_CSTM_ID
		AND T.ROLE_ID 		= S.ROLE_ID
		)
		WHEN MATCHED THEN
		  UPDATE SET
		    T.ROLE_NM = S.ROLE_NM,
		    T.ROLE_DESC = S.ROLE_DESC,
		    T.USE_YN = S.USE_YN,
		    T.DEL_YN = S.DEL_YN,
		    T.UPDATE_USER = S.UPDATE_USER,
		    T.UPDATE_DATE = S.UPDATE_DATE
		WHEN NOT MATCHED THEN 
    		INSERT (  SP_CSTM_ID,   ROLE_ID,   ROLE_NM,   ROLE_DESC,   USE_YN,   DEL_YN,   SORT_ORDER,   UPDATE_USER,   UPDATE_DATE )
   			VALUES (S.SP_CSTM_ID, S.ROLE_ID, S.ROLE_NM, S.ROLE_DESC, S.USE_YN, S.DEL_YN, S.SORT_ORDER, S.UPDATE_USER, S.UPDATE_DATE )
	</update>
	
	<delete id="deleteRole" parameterType="java.util.HashMap"  flushCache="true" >
		/*	admin.deleteRole
			Role 삭제
		*/
		DELETE FROM ADMIN.TBL_EXP_ROLE 
		WHERE SP_CSTM_ID = #{SP_CSTM_ID} 
		AND	  ROLE_ID	 = #{ROLE_ID}
	</delete>
	

	<!--
	USER 관리 
	 -->	
	<select id="getUserList" resultType="java.util.HashMap" flushCache="true"  useCache="false">
		/*	admin.getUserList
			User 리스트 조회 
		*/
		SELECT SP_CSTM_ID 
		,USER_ID
		,USER_NM
		,USER_DESC
		,E_MAIL
		,PHONE_NUM
		,USE_YN
		,DEL_YN
		,UPDATE_USER
		,TO_CHAR( UPDATE_DATE , 'YYYY-MM-DD HH24:MI:SS' ) UPDATE_DATE 
		FROM ADMIN.TBL_EXP_USER T
		WHERE 1 = 1
	</select>
	
	<update id="updateUser" parameterType="java.util.HashMap"  flushCache="true" >
		/*	admin.updateUser
			User  저장
		*/
		MERGE INTO ADMIN.TBL_EXP_USER T
		USING (
		  SELECT #{SP_CSTM_ID} 	AS SP_CSTM_ID,
		         #{USER_ID} 	AS USER_ID,
		         #{USER_NM} 	AS USER_NM,
		         #{USER_DESC} 	AS USER_DESC,
		         #{E_MAIL} 		AS E_MAIL,
		         #{PHONE_NUM} 	AS PHONE_NUM,
		         #{USE_YN} 		AS USE_YN,
		         #{DEL_YN} 		AS DEL_YN,
		         'admin' 		AS UPDATE_USER,
		         SYSDATE 		AS UPDATE_DATE
		  FROM dual
		) S
		ON (T.SP_CSTM_ID	= S.SP_CSTM_ID
		AND T.USER_ID 		= S.USER_ID
		)
		WHEN MATCHED THEN
		  UPDATE SET
		    T.USER_NM 		= S.USER_NM,
		    T.USER_DESC 	= S.USER_DESC,
		    T.E_MAIL 		= S.E_MAIL,
		    T.PHONE_NUM 	= S.PHONE_NUM,
		    T.USE_YN 		= S.USE_YN,
		    T.DEL_YN 		= S.DEL_YN,
		    T.UPDATE_USER 	= S.UPDATE_USER,
		    T.UPDATE_DATE 	= S.UPDATE_DATE
		WHEN NOT MATCHED THEN 
    		INSERT (  SP_CSTM_ID,   USER_ID,   USER_NM,   USER_DESC,   E_MAIL,   PHONE_NUM,   USE_YN,   DEL_YN,  UPDATE_USER,   UPDATE_DATE )
   			VALUES (S.SP_CSTM_ID, S.USER_ID, S.USER_NM, S.USER_DESC, S.E_MAIL, S.PHONE_NUM, S.USE_YN, S.DEL_YN, S.UPDATE_USER, S.UPDATE_DATE )
	</update>
	
	<delete id="deleteUser" parameterType="java.util.HashMap"  flushCache="true" >
		/*	admin.deleteUser
			User 삭제
		*/
		DELETE FROM ADMIN.TBL_EXP_USER 
		WHERE SP_CSTM_ID = #{SP_CSTM_ID} 
		AND	  USER_ID	 = #{USER_ID}
	</delete>
	
	
	<!--
	권한매핑 관리 ( 사용자 - 권한 )
	 -->	
	<select id="getAuthList" resultType="java.util.HashMap" flushCache="true"  useCache="false">
		/*	admin.getAuthList
			권한매핑 리스트 조회 
		*/
		SELECT SP_CSTM_ID 
		,USER_ID
		,ROLE_ID
		FROM ADMIN.TBL_EXP_AUTH T
		WHERE 1 = 1
	</select>
	
	<update id="updateAuth" parameterType="java.util.HashMap"  flushCache="true" >
		/*	admin.updateAuth
			권한 매핑 Auth  저장
		*/
		MERGE INTO ADMIN.TBL_EXP_AUTH T
		USING (
		  SELECT #{SP_CSTM_ID} 	AS SP_CSTM_ID
				#{USER_ID} 	AS USER_ID
				#{ROLE_ID} 	AS ROLE_ID
		  FROM dual
		) S
		ON (T.SP_CSTM_ID	= S.SP_CSTM_ID
		AND T.USER_ID 		= S.USER_ID
		)
		WHEN MATCHED THEN
		  UPDATE SET
		    T.ROLE_ID 		= S.ROLE_ID
		WHEN NOT MATCHED THEN 
    		INSERT (  SP_CSTM_ID,   USER_ID,   ROLE_ID)
   			VALUES (S.SP_CSTM_ID, S.USER_ID, S.ROLE_ID)
	</update>
	
	<delete id="deleteAuth" parameterType="java.util.HashMap"  flushCache="true" >
		/*	admin.deleteAuth
			권한매핑 Auth 삭제
		*/
		DELETE FROM ADMIN.TBL_EXP_AUTH 
		WHERE SP_CSTM_ID = #{SP_CSTM_ID} 
		AND	  USER_ID	 = #{USER_ID}
	</delete>
	
	<!--
	롤/매뉴 매핑 관리
	 -->	
	<select id="getRoleMenuMapList" resultType="java.util.HashMap" flushCache="true"  useCache="false">
		/*	admin.getRoleMenuMapList
			권한매핑 리스트 조회 
		*/
		SELECT SP_CSTM_ID 
		,USER_ID
		,ROLE_ID
		FROM ADMIN.TBL_EXP_ROLEMENU T
		WHERE 1 = 1
	</select>
	
	<update id="updateRoleMenuMap" parameterType="java.util.HashMap"  flushCache="true" >
		/*	admin.updateRoleMenuMap
			권한 매핑 Auth  저장
		*/
		MERGE INTO ADMIN.TBL_EXP_ROLEMENU T
		USING (
		  SELECT #{SP_CSTM_ID} 	AS SP_CSTM_ID
				#{ROLE_ID} 	AS ROLE_ID
				#{MENU_ID} 	AS MENU_ID
		  FROM dual
		) S
		ON (T.SP_CSTM_ID	= S.SP_CSTM_ID
		AND T.ROLE_ID 		= S.ROLE_ID
		AND T.MENU_ID 		= S.MENU_ID
		)
		WHEN MATCHED THEN
		  UPDATE SET
		    T.AUTH_TYPE		= S.AUTH_TYPE
		WHEN NOT MATCHED THEN 
    		INSERT (  SP_CSTM_ID,   ROLE_ID,   MENU_ID,	  AUTH_TYPE)
   			VALUES (S.SP_CSTM_ID, S.ROLE_ID, S.MENU_ID, S.AUTH_TYPE)
	</update>
	
	<delete id="deleteRoleMenuMap" parameterType="java.util.HashMap"  flushCache="true" >
		/*	admin.deleteRoleMenuMap
			권한매핑 Auth 삭제
		*/
		DELETE FROM ADMIN.TBL_EXP_ROLEMENU 
		WHERE SP_CSTM_ID = #{SP_CSTM_ID} 
		AND	  ROLE_ID	 = #{ROLE_ID}
		AND	  MENU_ID	 = #{MENU_ID}
	</delete>
	
</mapper>
